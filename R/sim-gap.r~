#' Simulating point patterns with gaps
#'
#' Simulates point locations from a point process with deletion areas.
#'
#' The \code{rchild} function may only take a single distributional
#' parameter. If the distribution for the number of children generated
#' by each parent is Poisson, then the native \code{rpois} is
#' appropriate, as this distribution has a single parameter. For
#' distributions with two or more parameters, those other than
#' \code{child.par} must be hard-coded into \code{rchild}. For
#' example, if a Binomial(n, 2, p) is required, then \code{function(n,
#' p) rbinom(n = n, size = 2, prob = p)} would be an appropriate
#' function for \code{rchild}.
#'
#' @return A matrix containing simulated point locations.
#' @param pars A named vector (or list?) of parameter values. Required
#' parameters are \code{D}, the density of parent points;
#' \code{child.disp} argument controlling the dispersion of children around their
#' parents, or the maximum radius of children around their
#' parents depending on if \code{dispersion} is chosen to be "gaussian" or "uniform"; and \code{child.par}, the parameter characterising the distribution for the number of children generated by each parent.
#' @param lims An argument specifying the limits of the domain, for 1DA matrix with two colums, corresponding to the upper
#' and lower limits of each dimension, respectively.
#' @param model A character specifying the type of void point process wanted, \code{void} by deafault. Other options are
#' \code{Mat1}, \code {Mat2}, and \code{dominance}.
#' @param domain.type A character specifying the type of domain requested, either \code{rectangular} or \code{hyperspherical} for
#' simulated point proces in 2 or more dimensions, by deafault this is \code{rectangular}.
#' @export
sim.ns <- function(pars = NULL, lims = rbind(c(0, 1), c(0, 1)), model="void",domain.type="rectangular"){
    ## Allowing lims to be a vector if only one dimension.
    if (!is.matrix(lims)){
        lims <- matrix(lims, nrow = 1)
    }
    ## Parameter values.
    D <- pars["D"]
    child.par <- pars["child.par"]
    child.disp <- pars["child.disp"]
    ## Number of dimensions.
    n.dims <- nrow(lims)
    ## Calculating survey area.
    area <- prod(apply(lims, 1, diff))
    ## Calculating expected number of parents.
    expected.n.parents <- D*area
    ## Generating number of parents.
    n.parents <- rpois(n = 1, lambda = expected.n.parents)
    ## Error if no parents generated.
    if (n.parents == 0){
        stop("No parents generated.")
    }
    ## Generating parent location points.
    parent.locs <- matrix(0, nrow = n.parents, ncol = n.dims)
    for (i in 1:n.dims){
        parent.locs[, i] <- runif(n.parents, lims[i, 1], lims[i, 2])
    }
    ## Generating the number of children spawned by each parent.
    n.childs <- rchild(n.parents, child.par)
    ## Total number of children.
    n.children <- sum(n.childs)
    ## Error if no children generated.
    if (n.children == 0){
        stop("No children generated.")
    }
    if(dispersion=="gaussian"){
        ## Generating children dispersion from parent.
        child.disper <- rmvnorm(n = n.children, mean = rep(0, n.dims),
                              sigma = child.disp^2*diag(n.dims))
        child.locs <- matrix(rep(parent.locs, times = rep(n.childs, n.dims)), ncol = n.dims) + child.disper
    }else if (dispersion=="uniform"){
         ## Generating children uniformly around parents in a hypersphere
         childs<-as.matrix(unifsphere(n=n.children,d=n.dims,R=child.disp))
         child.locs<-matrix(rep(parent.locs, times = rep(n.childs, n.dims)), ncol = n.dims) + childs
      
    }
    locs
}

